using System.Linq;
using System.Text;
using ConfigAssets.Sourcegen.Receivers;
using ConfigAssets.Sourcegen.Utils;
using Microsoft.CodeAnalysis;

namespace ConfigAssets.Sourcegen.Generators {
    [Generator]
    public class MetadataGenerator : ISourceGenerator {
        public void Initialize(GeneratorInitializationContext context) {
            context.RegisterForSyntaxNotifications(() => new AttributeSyntaxReceiver("Config"));
        }

        public void Execute(GeneratorExecutionContext context) {
            if (!(context.SyntaxReceiver is AttributeSyntaxReceiver receiver)) {
                return;
            }

            var names = ConfigurationFilter.FilterProviders(context.Compilation, receiver.Classes).Select(x => x.data.Metadata.FullyQualifiedName).ToList();

            if (!names.Any()) {
                return;
            }
            
            var sb = new StringBuilder(@"// <auto-generated />
using ConfigAssets.Metadata;
using System;
using System.Collections.Generic;

internal static class ConfigAssetsMetadata {
    internal static readonly Dictionary<string, AssetMetadata> ConfigurationTypes = new Dictionary<string, AssetMetadata> {
");
            foreach (var name in names) {
                sb.AppendLine($@"       {{ ""{name}"", new AssetMetadata(Type.GetType(""{name}"")) }},");
            }
            
            sb.Append($@"    }};
}}
");
            
            context.AddSource("ConfigAssetsMetadata.g.cs", sb.ToString());
        }
    }
}